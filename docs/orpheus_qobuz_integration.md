# OrpheusDL ↔ Qobuz Integration Notes

## 1. Module discovery and loading inside OrpheusDL
- `Orpheus` initialises its configuration store and enumerates every subdirectory under `modules/` that exposes an `interface.py`. This catalogue populates `module_list`, `module_settings`, and a lookup of URL/netloc constants to module names so Qobuz links resolve to the correct provider. Any duplicate netlocs raise an exception. 【F:external/orpheusdl/orpheus/core.py†L103-L162】
- When a module is first requested, `load_module` instantiates the provider's `ModuleInterface`, wiring in helpers such as the module-specific settings, a temporary storage controller (used for cached logins like Qobuz tokens), and global `OrpheusOptions` (download quality, debug switches, cover defaults). The loaded instance is cached for reuse. 【F:external/orpheusdl/orpheus/core.py†L179-L212】
- After instantiation Orpheus decides whether it should trigger a login. Modules that declare `ManualEnum.orpheus` logins (the Qobuz module does) receive stored credentials from `settings.json`; `load_module` checks the hashed credentials in the temporary storage and calls the module's `login` method if the cache is stale. JWT-enabled modules would also be refreshed here. 【F:external/orpheusdl/orpheus/core.py†L213-L240】
- Every module instance is exposed to downstream components through `module_controls`, which supplies the active module map, metadata, and a loader reference to the `Downloader`. 【F:external/orpheusdl/orpheus/core.py†L174-L178】

## 2. How OrpheusDL drives a module during downloads
- The orchestration entry point `orpheus_core_download` spins up a `Downloader` with the selected media queue. For each item it lazily loads the appropriate provider (e.g., Qobuz), enforces capability checks, and sets the `Downloader.service` pointer to that module. 【F:external/orpheusdl/orpheus/core.py†L356-L401】
- `Downloader.download_track` asks the active module for rich metadata by calling `get_track_info(track_id, quality_tier, codec_options, **extra_kwargs)`. The response determines file naming, codecs, playlist tagging, and follow-up API calls for album details if the configuration demands album-style folders. 【F:external/orpheusdl/orpheus/music_downloader.py†L288-L357】
- Once metadata is resolved, the downloader requests the actual audio payload through `service.get_track_download(**track_info.download_extra_kwargs)`. The module returns either a direct URL or a temporary file path; OrpheusDL handles saving the file, codec conversions, artwork fetching (potentially via third-party modules), and tagging. 【F:external/orpheusdl/orpheus/music_downloader.py†L371-L420】
- Similar module calls exist for albums, playlists, artists, credits, and search flows (`get_album_info`, `get_playlist_info`, `get_artist_info`, `get_track_credits`, `search`), allowing the downloader and CLI commands to stay provider-agnostic while the Qobuz module translates OrpheusDL requests into Qobuz API calls. 【F:external/orpheusdl-qobuz/interface.py†L235-L394】

## 3. Qobuz module surface area (`external/orpheusdl-qobuz`)
- The module advertises itself with `module_information`, defining the service name, supported modes (downloads + credits), configurable fields (App ID, App Secret, quality string), session credentials, netloc constants for link parsing, and a test URL. 【F:external/orpheusdl-qobuz/interface.py†L29-L48】
- During `ModuleInterface` initialisation, Orpheus supplies a `ModuleController` containing module settings and helpers. The constructor creates a `Qobuz` API client using the stored App ID/secret, restores any cached auth token from temporary storage, and records the chosen Orpheus quality tier plus a map of quality enums to Qobuz `format_id`s. 【F:external/orpheusdl-qobuz/interface.py†L51-L73】
- `login` wraps the API client's authentication helper, persisting the returned token so subsequent runs can reuse it without re-authenticating. 【F:external/orpheusdl-qobuz/interface.py†L74-L78】
- `get_track_info` merges multiple API calls: it fetches (or reuses cached) track JSON, normalises artist credits, builds tag metadata (ISRC/UPC/label/genre/replaygain), requests the streaming URL via `get_file_url`, and chooses codec/bitrate/sample-rate information based on the returned `format_id`. The method packages everything inside a `TrackInfo` dataclass, including download and credit kwargs for later calls. 【F:external/orpheusdl-qobuz/interface.py†L79-L187】
- `get_track_download` accepts the signed stream URL, downloads it into a temporary file via OrpheusDL utilities, and post-processes FLACs to backfill the MD5 signature using FFmpeg when Qobuz omits it. It returns a `TrackDownloadInfo` describing the temp file. 【F:external/orpheusdl-qobuz/interface.py†L189-L210】
- Album, playlist, and artist helpers reshape Qobuz responses into the shared OrpheusDL dataclasses, ensuring fields such as quality strings, booklet URLs, per-track extra kwargs, and artist album lists propagate back to the downloader. 【F:external/orpheusdl-qobuz/interface.py†L235-L313】
- Credit retrieval decomposes the performer string Qobuz returns into role-based groupings, while `search` prioritises ISRC lookups (when available) before falling back to textual queries, returning uniform `SearchResult` objects. 【F:external/orpheusdl-qobuz/interface.py†L315-L394】

## 4. Qobuz API client responsibilities
- The lightweight `Qobuz` wrapper constructs an Android client profile with fixed device headers and keeps a shared `requests` session from OrpheusDL's utilities. All REST calls go through `_get`, which applies those headers and raises module-scoped exceptions on non-2xx responses. 【F:external/orpheusdl-qobuz/qobuz_api.py†L6-L37】
- Authentication supports either email/password (hashed with MD5 per Qobuz requirements) or user ID/token pairs. Each call is signed: `create_signature` concatenates the method name, sorted parameters (excluding `app_id` and `user_auth_token`), the current timestamp, and the app secret before hashing with MD5. The resulting timestamp/signature pair is injected into every signed request. 【F:external/orpheusdl-qobuz/qobuz_api.py†L39-L78】
- Core endpoints exposed to the module include `catalog/search`, `track/getFileUrl`, `track/get`, `playlist/get`, `album/get`, and `artist/get`. `get_file_url` uses the stored auth token, desired `format_id`, and signature to fetch temporary download URLs, while the others fetch metadata payloads that `ModuleInterface` transforms. 【F:external/orpheusdl-qobuz/qobuz_api.py†L80-L144】

## 5. End-to-end download flow summary
1. The CLI or scheduler resolves the desired Qobuz item into a `DownloadTypeEnum` + ID, prompting `Orpheus.load_module("qobuz")` if the provider is not already cached. 【F:external/orpheusdl/orpheus/core.py†L179-L212】
2. `ModuleInterface` revives the saved auth token and waits for the downloader to request data. If the temporary storage flagged stale credentials, Orpheus calls `ModuleInterface.login` first. 【F:external/orpheusdl/orpheus/core.py†L213-L240】【F:external/orpheusdl-qobuz/interface.py†L51-L78】
3. `Downloader.download_track` asks Qobuz for `TrackInfo`, which triggers `get_track` and `get_file_url` API calls inside the module. The downloader uses the returned metadata to build folder/file names and tags. 【F:external/orpheusdl/orpheus/music_downloader.py†L288-L357】【F:external/orpheusdl-qobuz/interface.py†L79-L187】
4. The downloader invokes `get_track_download`, which downloads the signed URL into a temp path, computes any missing FLAC MD5, and hands back a `TrackDownloadInfo`. OrpheusDL then moves the file into place, performs tagging, artwork retrieval, and optional conversions. 【F:external/orpheusdl/orpheus/music_downloader.py†L371-L420】【F:external/orpheusdl-qobuz/interface.py†L189-L210】
5. Optional flows (album/playlist/artist queues, credit fetching, search, cover modules) reuse the corresponding Qobuz interface methods, keeping provider-specific HTTP logic confined to the module while the rest of OrpheusDL stays service-agnostic. 【F:external/orpheusdl-qobuz/interface.py†L235-L394】
